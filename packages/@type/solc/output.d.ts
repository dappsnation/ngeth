////////////
// RESULT //
////////////

import { YulBlock } from "./yul-ast";
import { SolidityNode, AstNodeLegacy } from "./solidity-ast";
import { OpCode } from "./opcode";
import { ABIDescription } from "./abi";

export interface CompilationResult {
  /** not present if no errors/warnings were encountered */
  errors?: CompilationError[]
  /** This contains the file-level outputs. In can be limited/filtered by the outputSelection settings */
  sources: {
    [contractName: string]: CompilationSource
  }
  /** This contains the contract-level outputs. It can be limited/filtered by the outputSelection settings */
  contracts: {
    /** If the language used has no contract names, this field should equal to an empty string. */
    [fileName: string]: {
      [contract: string]: CompiledContract
    }
  }
}

export interface lastCompilationResult {
  data: CompilationResult | null
  source: SourceWithTarget | null | undefined
} 

///////////
// ERROR //
///////////

export interface CompilationError {
  /** Location within the source file */
  sourceLocation?: SourceLocation
  /** Further locations (e.g. places of conflicting declarations) */
  secondarySourceLocations?: SourceLocation[],
  /** Error type */
  type: CompilationErrorType
  /** Component where the error originated, such as "general", "ewasm", etc. */
  component: 'general' | 'ewasm' | string
  severity: 'error' | 'Warning' | 'info'
  /** unique code for the cause of the error */
  errorCode?: string
  message: string
  /** the message formatted with source location */
  formattedMessage?: string
}

interface SourceLocation {
  file: string
  start: number
  end: number
  message?: string
}

type CompilationErrorType =
| 'JSONError'
| 'IOError'
| 'ParserError'
| 'DocstringParsingError'
| 'SyntaxError'
| 'DeclarationError'
| 'TypeError'
| 'UnimplementedFeatureError'
| 'InternalCompilerError'
| 'Exception'
| 'CompilerError'
| 'FatalError'
| 'Warning'


////////////
// SOURCE //
////////////
export interface CompilationSource {
  /** Identifier of the source (used in source maps) */
  id: number
  /** The AST object */
  ast: SolidityNode
  /** The legacy AST object */
  legacyAST: AstNodeLegacy
}

//////////////
// CONTRACT //
//////////////
export interface CompiledContract {
  /** The Ethereum Contract ABI. If empty, it is represented as an empty array. */
  abi?: ABIDescription[]
  /** Developer documentation (natural specification) */
  devdoc?: DeveloperDocumentation
  /** EVM-related outputs */
  evm?: EvmOutputs
  /** eWASM related outputs */
  ewasm: {
    /** S-expressions format */
    wast: string
    /** Binary format (hex string) */
    wasm: string
  }
  // See the Metadata Output documentation (serialised JSON string)
  metadata?: string
  storageLayout?: any
  /** User documentation (natural specification) */
  userdoc?: UserDocumentation
  /** Intermediate representation (string) */
  ir?: string
}

///////////////////////////
// NATURAL SPECIFICATION //
///////////////////////////

// Userdoc
export interface UserDocumentation {
  kind: 'user'
  methods?: Record<string, UserMethodDoc>
  stateVariables?: Record<string, UserMethodDoc>
  notice: string
}


export interface UserMethodDoc {
  notice: string
}

// Devdoc
export interface DeveloperDocumentation {
  kind: 'dev'
  version: number
  author?: string
  title?: string
  details?: string
  stateVariables?: Record<string, DevStateVariableDoc>
  events?: Record<string, DevEventDoc>
  methods?: Record<string, DevMethodDoc>
  [custom: `custom:${string}`]: string
}

export interface DevStateVariableDoc {
  details?: string
  return?: string
  [custom: `custom:${string}`]: string
}

export interface DevEventDoc {
  details?: string
  params?: {
    [param: string]: string
  }
  [custom: `custom:${string}`]: string
}

export interface DevMethodDoc {
  details?: string
  return?: string
  returns?: {
    [param: string]: string
  }
  params?: {
    [param: string]: string
  }
  [custom: `custom:${string}`]: string
}

////////////////
// EVM OUTPUT //
////////////////
export interface EvmOutputs {
  assembly?: string
  /** Bytecode and related details. */
  bytecode: Bytecode
  legacyAssembly: Record<string, LegacyAssembly[]> | null
  deployedBytecode: DeployedBytecode
  /** Function gas estimates */
  gasEstimates?: GasEstimates | null
  /** The list of function hashes */
  methodIdentifiers: {
    [functionIdentifier: string]: string
  }
}

export interface Bytecode {
  /** 
   * Debugging data at the level of functions.
   * Set of functions including compiler-internal and user-defined function.
   */
  functionDebugData: {
    [internalName: string]: FunctionDebugData
  }
  /** Array of sources generated by the compiler. Currently only contains a single Yul file. */
  generatedSources: GeneratedSources[],
  /** The bytecode as a hex string. */
  object: string
  /** Opcodes list */
  opcodes: string
  /** The source mapping as a string. See the source mapping definition. */
  sourceMap?: string
  /** If given, this is an unlinked object. */
  linkReferences: {
    [contractName: string]: {
      /** Byte offsets into the bytecode. */
      [library: string]: { start: number; length: number }[]
    }
  }
}

export interface DeployedBytecode extends Bytecode {
  immutableReferences?: {
    /** Byte offsets into the bytecode. */
    [nodeId: string]: { start: number; length: number }[]
  }
}

export interface FunctionDebugData {
  /** Byte offset into the bytecode where the function starts */
  entryPoint: number;
  /** AST ID of the function definition or null for compiler-internal functions */
  id: number | null;
  /** Number of EVM stack slots for the function parameters */
  parameterSlots: number;
  /** Number of EVM stack slots for the return values */
  returnSlots: number;
}

export interface GeneratedSources {
    /** Yul AST */
    ast: YulBlock
    /** Source file in its text form (may contain comments) */ 
    contents: string
    /** Source file ID, used for source references, same namespace as the Solidity source files */
    id: number
    language: 'Yul'
    name: string
}

export interface GasEstimates {
  creation: {
    codeDepositCost: string
    executionCost: 'infinite' | `${number}`
    totalCost: 'infinite' | `${number}`
  }
  external: {
    [functionIdentifier: string]: 'infinite' | `${number}`
  }
  internal: {
    [functionIdentifier: string]: 'infinite' | `${number}`
  }
}

export interface LegacyAssembly {
  ['.code']: LegacyAssemblyNode[];
  ['.data']: Record<string, {
    ['.auxdata']: string;
    ['.code']: LegacyAssemblyNode[];
  }>
}

export interface LegacyAssemblyNode {
  begin: number;
  end: number;
  name: OpCode | 'PUSH [tag]';
  source: number;
  value: string;
}

export interface StorageLayout {
  storage: StorageNode[];
  types: Record<string, StorageType> | null
}

export interface StorageNode {
  astId: string;
  contract: string;
  label: string;
  offset: number;
  slot: `${number}`;
  type: string;
}

export interface StorageType {
  base?: string;
  encoding: string;
  label: string;
  numberOfBytes: `${number}`;
}

/////////////
// SOURCES //
/////////////
export interface CompilationFileSources {
  [fileName: string]: {
    // Optional: keccak256 hash of the source file
    keccak256?: string,
    // Required (unless "urls" is used): literal contents of the source file
    content: string,
    urls?: string[]
  }
}

export interface SourceWithTarget {
  sources?: CompilationFileSources,
  target?: string | null | undefined
}